#!/usr/bin/env python

"""Patches computation of squared ME to keep interference terms only.

This script patches Fortran code generated for each subprocess.  When
summing over helicities, it computes the squared matrix element as is,
then inverts the sign of the given coupling, recomputes the squared
matrix element, and finally returns the half-difference of the two. This
way only terms with odd degrees in the coupling are kept.

Definitions of couplings can be found in file couplings.py in the
directory with the model.

This trick was proposed by Sebastien Wertz.
"""

from __future__ import print_function
import argparse
import os
import re
import shutil
import tempfile


if __name__ == '__main__':
    
    arg_parser = argparse.ArgumentParser(epilog=__doc__)
    arg_parser.add_argument('dir', help='Directory generated by MadGraph for a given process')
    arg_parser.add_argument(
        'coupling', type=int,
        help='Index of the coupling whose sign will be inversed'
    )
    args = arg_parser.parse_args()
    
    coupling_name = 'GC_{}'.format(args.coupling)
    
    
    sub_proc_dir = os.path.join(args.dir, 'SubProcesses')
    
    if not os.path.exists(sub_proc_dir):
        raise RuntimeError(
            'Directory "{}" does not contain required subdirectory "SubProcesses".'.format(
                args.dir
            )
        )
    
    regex_include = re.compile(r'(\s*)INCLUDE\s+\'maxamps\.inc\'\s*')
    regex_me = re.compile(r'(\s*)T=(MATRIX1\(.+\))\s*')
    
    
    # Loop over all subprocesses
    for entry in os.listdir(sub_proc_dir):
        if not os.path.isdir(os.path.join(sub_proc_dir, entry)):
            continue
        
        src_file_name = os.path.join(sub_proc_dir, entry, 'matrix1.f')
        print('Patching file "{}".'.format(src_file_name))
        
        
        src_file = open(src_file_name)
        out_file = tempfile.NamedTemporaryFile(mode='w', delete=False)
        out_file_name = out_file.name
        
        
        # Copy content of the source file with up to the end of the
        # include block.  Add inclusion of file with couplings.
        while True:
            line = src_file.readline()
            
            if not line:
                raise RuntimeError(
                    'Failed to locate the end of the include block in file "{}".'.format(
                        src_file_name
                    )
                )
            
            out_file.write(line)
            match = regex_include.match(line)
            
            if match:
                out_file.write(match.group(1) + 'INCLUDE \'coupl.inc\'\n')
                break
        
        
        # Copy the remaining content of the source file.  When the
        # computation of the squared ME is encountered, apply the trick
        # with flipping of the sign of selected coupling.
        num_me_patches = 0
        
        while True:
            line = src_file.readline()
            
            if not line:
                break
            
            out_file.write(line)
            match = regex_me.match(line)
            
            if match:
                spacing = match.group(1)
                me_call = match.group(2)
                
                out_file.write('{s}{c}=-{c}\n'.format(s=spacing, c=coupling_name))
                out_file.write('{}T=5D-1*(T-{})\n'.format(spacing, me_call))
                out_file.write('{s}{c}=-{c}\n'.format(s=spacing, c=coupling_name))
                
                num_me_patches += 1
        
        if num_me_patches != 2:
            raise RuntimeError(
                'In file "{}" found {} places in which the squared matrix element is evaluated '
                'while 2 places expected.'.format(src_file_name, num_me_patches)
            )
        
        
        src_file.close()
        out_file.close()
        
        shutil.move(src_file_name, src_file_name + '.orig')
        shutil.move(out_file_name, src_file_name)
